"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runWithOptions = void 0;
const chalk_1 = __importDefault(require("chalk"));
const HandledError_1 = require("./services/HandledError");
const logger_1 = require("./services/logger");
const sequentially_1 = require("./services/sequentially");
const cherrypickAndCreateTargetPullRequest_1 = require("./ui/cherrypickAndCreateTargetPullRequest");
const getCommits_1 = require("./ui/getCommits");
const getTargetBranches_1 = require("./ui/getTargetBranches");
const maybeSetupRepo_1 = require("./ui/maybeSetupRepo");
async function runWithOptions(options) {
    logger_1.logger.verbose('Backport options', options);
    if (options.dryRun) {
        logger_1.consoleLog(chalk_1.default.red('Dry run: Nothing will be pushed to Github\n'));
    }
    const commits = await getCommits_1.getCommits(options);
    const targetBranches = await getTargetBranches_1.getTargetBranches(options, commits);
    await maybeSetupRepo_1.maybeSetupRepo(options);
    const results = [];
    await sequentially_1.sequentially(targetBranches, async (targetBranch) => {
        logger_1.logger.info(`Backporting ${JSON.stringify(commits)} to ${targetBranch}`);
        try {
            const pullRequest = await cherrypickAndCreateTargetPullRequest_1.cherrypickAndCreateTargetPullRequest({
                options,
                commits,
                targetBranch,
            });
            results.push({
                targetBranch,
                success: true,
                pullRequestUrl: pullRequest.url,
            });
        }
        catch (e) {
            const isHandledError = e instanceof HandledError_1.HandledError;
            const errorMessage = isHandledError
                ? logger_1.redact(e.message)
                : 'An unhandled error occurred. Please consult the logs';
            results.push({ targetBranch, success: false, errorMessage, error: e });
            logger_1.consoleLog(errorMessage);
        }
    });
    // return the results for consumers to programatically read
    return results;
}
exports.runWithOptions = runWithOptions;
