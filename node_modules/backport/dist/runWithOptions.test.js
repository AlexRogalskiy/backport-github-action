"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const inquirer_1 = __importDefault(require("inquirer"));
const nock_1 = __importDefault(require("nock"));
const runWithOptions_1 = require("./runWithOptions");
const childProcess = __importStar(require("./services/child-process-promisified"));
const fs = __importStar(require("./services/fs-promisified"));
const commitsByAuthorMock_1 = require("./services/github/v4/mocks/commitsByAuthorMock");
const nockHelpers_1 = require("./test/nockHelpers");
describe('runWithOptions', () => {
    let rpcExecMock;
    let rpcExecOriginalMock;
    let inquirerPromptMock;
    let res;
    let createPullRequestCalls;
    let commitsByAuthorCalls;
    let authorIdCalls;
    afterEach(() => {
        jest.clearAllMocks();
        nock_1.default.cleanAll();
    });
    beforeEach(async () => {
        const options = {
            accessToken: 'myAccessToken',
            all: false,
            assignees: [],
            author: 'sqren',
            autoFixConflicts: undefined,
            branchLabelMapping: undefined,
            ci: false,
            dryRun: false,
            editor: 'code',
            fork: true,
            gitHostname: 'github.com',
            githubApiBaseUrlV3: 'https://api.github.com',
            githubApiBaseUrlV4: 'http://localhost/graphql',
            mainline: undefined,
            maxNumber: 10,
            multipleBranches: false,
            multipleCommits: false,
            noVerify: true,
            path: undefined,
            prDescription: 'myPrDescription',
            prTitle: 'myPrTitle {targetBranch} {commitMessages}',
            pullNumber: undefined,
            repoName: 'kibana',
            repoOwner: 'elastic',
            resetAuthor: false,
            sha: undefined,
            sourceBranch: 'mySourceBranch',
            sourcePRLabels: [],
            prFilter: undefined,
            targetBranches: [],
            targetBranchChoices: [
                { name: '6.x' },
                { name: '6.0' },
                { name: '5.6' },
                { name: '5.5' },
                { name: '5.4' },
            ],
            targetPRLabels: [],
            username: 'sqren',
            verbose: false,
        };
        rpcExecMock = jest
            .spyOn(childProcess, 'exec')
            .mockResolvedValue({ stdout: 'success', stderr: '' });
        rpcExecOriginalMock = jest.spyOn(childProcess, 'execAsCallback');
        jest.spyOn(fs, 'writeFile').mockResolvedValue(undefined);
        inquirerPromptMock = jest
            .spyOn(inquirer_1.default, 'prompt')
            .mockImplementationOnce((async (args) => {
            return { promptResult: args[0].choices[0].value };
        }))
            .mockImplementationOnce((async (args) => {
            return { promptResult: args[0].choices[0].name };
        }));
        authorIdCalls = nockHelpers_1.mockGqlRequest({
            name: 'AuthorId',
            statusCode: 200,
            body: { data: { user: { id: 'sqren_author_id' } } },
        });
        commitsByAuthorCalls = nockHelpers_1.mockGqlRequest({
            name: 'CommitsByAuthor',
            statusCode: 200,
            body: { data: commitsByAuthorMock_1.commitsWithPullRequestsMock },
        });
        const scope = nock_1.default('https://api.github.com')
            .post('/repos/elastic/kibana/pulls')
            .reply(200, { html_url: 'pull request url', number: 1337 });
        createPullRequestCalls = nockHelpers_1.getNockCallsForScope(scope);
        res = await runWithOptions_1.runWithOptions(options);
        scope.done();
    });
    it('returns pull request', () => {
        expect(res).toEqual([
            {
                pullRequestUrl: 'pull request url',
                success: true,
                targetBranch: '6.x',
            },
        ]);
    });
    it('creates pull request', () => {
        expect(createPullRequestCalls).toEqual([
            {
                base: '6.x',
                body: 'Backports the following commits to 6.x:\n - Add ðŸ‘» (2e63475c)\n\nmyPrDescription',
                head: 'sqren:backport/6.x/commit-2e63475c',
                title: 'myPrTitle 6.x Add ðŸ‘» (2e63475c)',
            },
        ]);
    });
    it('it retrieves author id', () => {
        expect(authorIdCalls).toMatchInlineSnapshot(`
      Array [
        Object {
          "query": "
          query AuthorId($login: String!) {
            user(login: $login) {
              id
            }
          }
        ",
          "variables": Object {
            "login": "sqren",
          },
        },
      ]
    `);
    });
    it('it retrieves commits by author', () => {
        expect(commitsByAuthorCalls.map((body) => body.variables)).toEqual([
            {
                authorId: 'sqren_author_id',
                historyPath: null,
                maxNumber: 10,
                repoName: 'kibana',
                repoOwner: 'elastic',
                sourceBranch: 'mySourceBranch',
            },
        ]);
    });
    it('prompt calls should match snapshot', () => {
        expect(inquirer_1.default.prompt).toHaveBeenCalledTimes(2);
        expect(inquirerPromptMock.mock.calls).toMatchSnapshot();
    });
    it('exec should be called with correct args', () => {
        expect(rpcExecMock).toHaveBeenCalledTimes(10);
        expect(rpcExecMock.mock.calls).toMatchSnapshot();
    });
    it('git clone should be called with correct args', () => {
        expect(rpcExecOriginalMock).toHaveBeenCalledTimes(1);
        expect(rpcExecOriginalMock.mock.calls).toMatchSnapshot();
    });
});
