"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getOptions = void 0;
const fetchDefaultRepoBranchAndPerformStartupChecks_1 = require("../services/github/v4/fetchDefaultRepoBranchAndPerformStartupChecks");
const logger_1 = require("./../services/logger");
const cliArgs_1 = require("./cliArgs");
const config_1 = require("./config/config");
const getValidatedOptions_1 = require("./getValidatedOptions");
async function getOptions(argv, optionsFromModule) {
    const optionsFromConfig = await config_1.getOptionsFromConfigFiles(optionsFromModule === null || optionsFromModule === void 0 ? void 0 : optionsFromModule.ci);
    const optionsFromCli = cliArgs_1.getOptionsFromCliArgs({ ...optionsFromConfig, ...optionsFromModule }, argv);
    logger_1.setRedactedAccessToken(optionsFromCli.accessToken);
    // set log level when all config options have been taken into account
    logger_1.setLogLevel({ verbose: optionsFromCli.verbose });
    if (optionsFromCli.ci) {
        logger_1.addConsoleTransport();
    }
    // TODO: move `getValidatedOptions` to `getOptionsFromCliArgs`
    const validatedOptions = getValidatedOptions_1.getValidatedOptions(optionsFromCli);
    // TODO: make `username` optional by defaulting to `currentUsername`
    const { defaultBranch } = await fetchDefaultRepoBranchAndPerformStartupChecks_1.fetchDefaultRepoBranchAndPerformStartupChecks(validatedOptions);
    return {
        ...validatedOptions,
        // use the default branch as source branch (normally master) unless an explicit `sourceBranch` has been given
        sourceBranch: validatedOptions.sourceBranch
            ? validatedOptions.sourceBranch
            : defaultBranch,
    };
}
exports.getOptions = getOptions;
