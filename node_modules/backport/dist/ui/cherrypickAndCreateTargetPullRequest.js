"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBackportBranchName = exports.cherrypickAndCreateTargetPullRequest = void 0;
const rest_1 = require("@octokit/rest");
const chalk_1 = __importDefault(require("chalk"));
const github_backport_1 = require("github-backport");
const lodash_difference_1 = __importDefault(require("lodash.difference"));
const lodash_isempty_1 = __importDefault(require("lodash.isempty"));
const ora = require("ora");
const HandledError_1 = require("../services/HandledError");
const child_process_promisified_1 = require("../services/child-process-promisified");
const env_1 = require("../services/env");
const git_1 = require("../services/git");
const commitFormatters_1 = require("../services/github/commitFormatters");
const addAssigneesToPullRequest_1 = require("../services/github/v3/addAssigneesToPullRequest");
const addLabelsToPullRequest_1 = require("../services/github/v3/addLabelsToPullRequest");
const createPullRequest_1 = require("../services/github/v3/createPullRequest");
const fetchExistingPullRequest_1 = require("../services/github/v4/fetchExistingPullRequest");
const logger_1 = require("../services/logger");
const prompts_1 = require("../services/prompts");
const sequentially_1 = require("../services/sequentially");
const shouldBackportViaApi_1 = require("./shouldBackportViaApi");
async function cherrypickAndCreateTargetPullRequest({ options, commits, targetBranch, }) {
    const backportBranch = getBackportBranchName(targetBranch, commits);
    const repoForkOwner = git_1.getRepoForkOwner(options);
    logger_1.consoleLog(`\n${chalk_1.default.bold(`Backporting to ${targetBranch}:`)}`);
    const prPayload = {
        owner: options.repoOwner,
        repo: options.repoName,
        title: createPullRequest_1.getTitle({ options, commits, targetBranch }),
        body: createPullRequest_1.getBody({ options, commits, targetBranch }),
        head: `${repoForkOwner}:${backportBranch}`,
        base: targetBranch,
    };
    // backport using Github API
    const targetPullRequest = shouldBackportViaApi_1.shouldBackportViaApi(options, commits)
        ? await backportViaGithubApi({
            options,
            prPayload,
            commits,
        })
        : await backportViaFilesystem({
            options,
            prPayload,
            targetBranch,
            backportBranch,
            commits,
        });
    // add assignees to target pull request
    if (options.assignees.length > 0) {
        await addAssigneesToPullRequest_1.addAssigneesToPullRequest(options, targetPullRequest.number, options.assignees);
    }
    // add labels to target pull request
    if (options.targetPRLabels.length > 0) {
        await addLabelsToPullRequest_1.addLabelsToPullRequest(options, targetPullRequest.number, options.targetPRLabels);
    }
    // add labels to source pull requests
    if (options.sourcePRLabels.length > 0) {
        const promises = commits.map((commit) => {
            if (commit.pullNumber) {
                return addLabelsToPullRequest_1.addLabelsToPullRequest(options, commit.pullNumber, options.sourcePRLabels);
            }
        });
        await Promise.all(promises);
    }
    logger_1.consoleLog(`View pull request: ${targetPullRequest.url}`);
    return targetPullRequest;
}
exports.cherrypickAndCreateTargetPullRequest = cherrypickAndCreateTargetPullRequest;
async function backportViaGithubApi({ options, prPayload, commits, }) {
    const { pullNumber } = commits[0];
    if (!pullNumber) {
        throw new Error('Cannot backup via API without pull number');
    }
    logger_1.logger.info('Backporting via api');
    const spinner = ora(`Performing backport via Github API...`).start();
    const octokit = new rest_1.Octokit({
        auth: options.accessToken,
        baseUrl: options.githubApiBaseUrlV3,
        log: logger_1.logger,
    });
    let number;
    try {
        const { head } = fetchExistingPullRequest_1.splitHead(prPayload);
        number = await github_backport_1.backportPullRequest({
            octokit,
            pullRequestNumber: pullNumber,
            ...prPayload,
            head,
        });
        spinner.succeed();
    }
    catch (e) {
        spinner.fail();
        // PR already exists
        if (e.name === 'HttpError' &&
            e.message.includes('Reference already exists')) {
            const res = await fetchExistingPullRequest_1.fetchExistingPullRequest({ options, prPayload });
            throw new HandledError_1.HandledError(`Pull request already exists: ${res === null || res === void 0 ? void 0 : res.url}`);
        }
        // merge conflict
        if (e.message.includes('could not be cherry-picked on top of')) {
            throw new HandledError_1.HandledError('Commit could not be cherrypicked due to conflicts');
        }
        throw e;
    }
    const url = `https://github.com/${options.repoOwner}/${options.repoName}/pull/${number}`;
    return { number, url };
}
async function backportViaFilesystem({ options, prPayload, commits, targetBranch, backportBranch, }) {
    logger_1.logger.info('Backporting via filesystem');
    await git_1.createBackportBranch({ options, targetBranch, backportBranch });
    await sequentially_1.sequentially(commits, (commit) => waitForCherrypick(options, commit, targetBranch));
    if (options.resetAuthor) {
        await git_1.setCommitAuthor(options, options.username);
    }
    await git_1.pushBackportBranch({ options, backportBranch });
    await git_1.deleteBackportBranch({ options, backportBranch });
    return createPullRequest_1.createPullRequest({ options, prPayload });
}
/*
 * Returns the name of the backport branch without remote name
 *
 * Examples:
 * For a single PR: `backport/7.x/pr-1234`
 * For a single commit: `backport/7.x/commit-abcdef`
 * For multiple: `backport/7.x/pr-1234_commit-abcdef`
 */
function getBackportBranchName(targetBranch, commits) {
    const refValues = commits
        .map((commit) => commit.pullNumber
        ? `pr-${commit.pullNumber}`
        : `commit-${commitFormatters_1.getShortSha(commit.sha)}`)
        .join('_')
        .slice(0, 200);
    return `backport/${targetBranch}/${refValues}`;
}
exports.getBackportBranchName = getBackportBranchName;
async function waitForCherrypick(options, commit, targetBranch) {
    const spinnerText = `Cherry-picking: ${chalk_1.default.greenBright(commit.formattedMessage)}`;
    const cherrypickSpinner = ora(spinnerText).start();
    if (options.dryRun) {
        cherrypickSpinner.succeed(`Dry run: ${spinnerText}`);
        return;
    }
    try {
        const { needsResolving } = await git_1.cherrypick(options, commit);
        // no conflicts encountered
        if (!needsResolving) {
            cherrypickSpinner.succeed();
            return;
        }
        // cherrypick failed due to conflicts
        cherrypickSpinner.fail();
    }
    catch (e) {
        cherrypickSpinner.fail();
        throw e;
    }
    // resolve conflicts automatically
    if (options.autoFixConflicts) {
        const autoResolveSpinner = ora('Attempting to resolve conflicts automatically').start();
        const filesWithConflicts = await git_1.getConflictingFiles(options);
        const repoPath = env_1.getRepoPath(options);
        const didAutoFix = await options.autoFixConflicts({
            files: filesWithConflicts,
            directory: repoPath,
            logger: logger_1.logger,
            targetBranch,
        });
        // conflicts were automatically resolved
        if (didAutoFix) {
            autoResolveSpinner.succeed();
            return;
        }
        autoResolveSpinner.fail();
    }
    if (options.ci) {
        throw new HandledError_1.HandledError('Commit could not be cherrypicked due to conflicts');
    }
    /*
     * Commit could not be cleanly cherrypicked: Initiating conflict resolution
     */
    if (options.editor) {
        const repoPath = env_1.getRepoPath(options);
        await child_process_promisified_1.exec(`${options.editor} ${repoPath}`, {});
    }
    // list files with conflict markers + unstaged files and require user to resolve them
    await listConflictingAndUnstagedFiles(options);
    // Conflicts should be resolved and files staged at this point
    const stagingSpinner = ora(`Finalizing cherrypick`).start();
    try {
        // Run `git commit`
        await git_1.finalizeCherrypick(options);
        stagingSpinner.succeed();
    }
    catch (e) {
        stagingSpinner.fail();
        throw e;
    }
}
async function listConflictingAndUnstagedFiles(options) {
    const checkForProblems = async (retries = 0) => {
        const [conflictingFiles, _unstagedFiles] = await Promise.all([
            git_1.getConflictingFiles(options),
            git_1.getUnstagedFiles(options),
        ]);
        const unstagedFiles = lodash_difference_1.default(_unstagedFiles, conflictingFiles);
        const hasConflictingFiles = !lodash_isempty_1.default(conflictingFiles);
        const hasUnstagedFiles = !lodash_isempty_1.default(unstagedFiles);
        if (!hasConflictingFiles && !hasUnstagedFiles) {
            return;
        }
        // add divider between prompts
        if (retries > 0) {
            logger_1.consoleLog('\n----------------------------------------\n');
        }
        // show conflict section if there are conflicting files
        const conflictSection = hasConflictingFiles
            ? `Conflicting files:\n${chalk_1.default.reset(conflictingFiles.map((file) => ` - ${file}`).join('\n'))}`
            : '';
        const unstagedSection = hasUnstagedFiles
            ? `Unstaged files:\n${chalk_1.default.reset(unstagedFiles.map((file) => ` - ${file}`).join('\n'))}`
            : '';
        const res = await prompts_1.confirmPrompt(`${chalk_1.default.reset(`Please fix the issues in: ${env_1.getRepoPath(options)}`)}

${conflictSection}
${unstagedSection}

Press ENTER when the conflicts are resolved and files are staged`);
        if (!res) {
            throw new HandledError_1.HandledError('Aborted');
        }
        const MAX_RETRIES = 100;
        if (retries++ > MAX_RETRIES) {
            throw new Error(`Maximum number of retries (${MAX_RETRIES}) exceeded`);
        }
        await checkForProblems(retries);
    };
    await checkForProblems();
}
