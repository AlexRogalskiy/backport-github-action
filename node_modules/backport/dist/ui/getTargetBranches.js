"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTargetBranchChoices = exports.getTargetBranches = void 0;
const lodash_flatmap_1 = __importDefault(require("lodash.flatmap"));
const lodash_isempty_1 = __importDefault(require("lodash.isempty"));
const HandledError_1 = require("../services/HandledError");
const prompts_1 = require("../services/prompts");
const filterEmpty_1 = require("../utils/filterEmpty");
function getTargetBranches(options, commits) {
    // target branches already specified (in contrast to letting the user choose from a list)
    if (!lodash_isempty_1.default(options.targetBranches)) {
        return options.targetBranches;
    }
    // combine target branches from commits that were selected for backporting
    const targetBranchesFromLabels = lodash_flatmap_1.default(commits, (commit) => commit.targetBranchesFromLabels).filter(filterEmpty_1.filterEmpty);
    // sourceBranch should be the same for all commits, so picking `sourceBranch` from the first commit should be fine ðŸ¤ž
    // this is specifically needed when backporting a PR like `backport --pr 123` and the source PR was merged to a non-default (aka non-master) branch.
    const { sourceBranch } = commits[0];
    const targetBranchChoices = getTargetBranchChoices(options, targetBranchesFromLabels, sourceBranch);
    // automatically select the pre-checked branches
    if (options.ci) {
        const branches = targetBranchChoices
            .filter((branch) => branch.checked)
            .map((branch) => branch.name);
        if (lodash_isempty_1.default(branches)) {
            throw new HandledError_1.HandledError(`There are no branches to backport to. Aborting.`);
        }
        return branches;
    }
    // render interactive list of branches
    return prompts_1.promptForTargetBranches({
        targetBranchChoices,
        isMultipleChoice: options.multipleBranches,
    });
}
exports.getTargetBranches = getTargetBranches;
function getTargetBranchChoices(options, targetBranchesFromLabels, sourceBranch) {
    // exclude sourceBranch from targetBranchChoices
    const targetBranchesFromOptions = options.targetBranchChoices.filter((choice) => choice.name !== sourceBranch);
    if (lodash_isempty_1.default(targetBranchesFromOptions)) {
        throw new HandledError_1.HandledError('Missing target branch choices');
    }
    // automatially select target branches based on pull request labels
    const preSelectedBranches = targetBranchesFromOptions.map((choice) => {
        const isChecked = targetBranchesFromLabels.includes(choice.name);
        return { ...choice, checked: isChecked };
    });
    // if none of the choices are pre-selected (via PR labels) use the default selection (given via config options)
    const hasAnySelections = preSelectedBranches.some((branch) => branch.checked);
    if (!hasAnySelections && !options.ci) {
        return targetBranchesFromOptions;
    }
    return preSelectedBranches;
}
exports.getTargetBranchChoices = getTargetBranchChoices;
