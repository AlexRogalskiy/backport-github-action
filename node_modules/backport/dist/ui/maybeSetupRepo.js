"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.maybeSetupRepo = void 0;
const make_dir_1 = __importDefault(require("make-dir"));
const ora = require("ora");
const env_1 = require("../services/env");
const git_1 = require("../services/git");
async function maybeSetupRepo(options) {
    const isAlreadyCloned = await git_1.repoExists(options);
    // clone repo if folder does not already exists
    if (!isAlreadyCloned) {
        const spinner = ora().start();
        try {
            const spinnerCloneText = 'Cloning repository (one-time operation)';
            spinner.text = `0% ${spinnerCloneText}`;
            await make_dir_1.default(env_1.getRepoOwnerPath(options));
            await git_1.cloneRepo(options, (progress) => {
                spinner.text = `${progress}% ${spinnerCloneText}`;
            });
            spinner.succeed(`100% ${spinnerCloneText}`);
        }
        catch (e) {
            spinner.fail();
            await git_1.deleteRepo(options);
            throw e;
        }
    }
    // delete default "origin" remote to avoid confusion
    await git_1.deleteRemote(options, 'origin');
    // ensure remote are setup with latest accessToken
    await git_1.deleteRemote(options, options.username);
    await git_1.addRemote(options, options.username);
    if (options.username !== options.repoOwner) {
        await git_1.deleteRemote(options, options.repoOwner);
        await git_1.addRemote(options, options.repoOwner);
    }
}
exports.maybeSetupRepo = maybeSetupRepo;
