"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTitle = exports.getBody = exports.createPullRequest = void 0;
const rest_1 = require("@octokit/rest");
const chalk_1 = __importDefault(require("chalk"));
const ora_1 = __importDefault(require("ora"));
const HandledError_1 = require("../../HandledError");
const logger_1 = require("../../logger");
const fetchExistingPullRequest_1 = require("../v4/fetchExistingPullRequest");
const getGithubV3ErrorMessage_1 = require("./getGithubV3ErrorMessage");
async function createPullRequest({ options, prPayload, }) {
    logger_1.logger.info(`Creating PR with title: "${prPayload.title}". ${prPayload.head} -> ${prPayload.base}`);
    const { accessToken, dryRun, githubApiBaseUrlV3 } = options;
    const spinner = ora_1.default(`Creating pull request`).start();
    if (dryRun) {
        spinner.succeed('Dry run: Creating pull request');
        // output PR summary
        logger_1.consoleLog(chalk_1.default.bold('\nPull request summary:'));
        logger_1.consoleLog(`Branch: ${prPayload.head} -> ${prPayload.base}`);
        logger_1.consoleLog(`Title: ${prPayload.title}`);
        logger_1.consoleLog(`Body: ${prPayload.body}\n`);
        return { url: 'example_url', number: 1337 };
    }
    try {
        const octokit = new rest_1.Octokit({
            auth: accessToken,
            baseUrl: githubApiBaseUrlV3,
            log: logger_1.logger,
        });
        const res = await octokit.pulls.create(prPayload);
        spinner.succeed();
        return {
            url: res.data.html_url,
            number: res.data.number,
        };
    }
    catch (e) {
        // retrieve url for existing
        try {
            const existingPR = await fetchExistingPullRequest_1.fetchExistingPullRequest({
                options,
                prPayload,
            });
            if (existingPR) {
                spinner.succeed('Updating existing pull request');
                return existingPR;
            }
        }
        catch (e) {
            logger_1.logger.warn('Could not retrieve existing pull request', e);
            // swallow error
        }
        spinner.fail();
        throw new HandledError_1.HandledError(`Could not create pull request: ${getGithubV3ErrorMessage_1.getGithubV3ErrorMessage(e)}`);
    }
}
exports.createPullRequest = createPullRequest;
function getBody({ options, commits, targetBranch, }) {
    const commitMessages = commits
        .map((commit) => ` - ${commit.formattedMessage}`)
        .join('\n');
    const bodySuffix = options.prDescription
        ? `\n\n${options.prDescription}`
        : '';
    return `Backports the following commits to ${targetBranch}:\n${commitMessages}${bodySuffix}`;
}
exports.getBody = getBody;
function getTitle({ options, commits, targetBranch, }) {
    const commitMessages = commits
        .map((commit) => commit.formattedMessage)
        .join(' | ');
    return options.prTitle
        .replace('{targetBranch}', targetBranch)
        .replace('{commitMessages}', commitMessages)
        .slice(0, 240);
}
exports.getTitle = getTitle;
