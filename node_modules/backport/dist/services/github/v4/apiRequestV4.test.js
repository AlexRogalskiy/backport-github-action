"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const nock_1 = __importDefault(require("nock"));
const nockHelpers_1 = require("../../../test/nockHelpers");
const HandledError_1 = require("../../HandledError");
const apiRequestV4_1 = require("./apiRequestV4");
describe('apiRequestV4', () => {
    afterEach(() => {
        nock_1.default.cleanAll();
    });
    describe('when request succeeds', () => {
        let res;
        let commitsByAuthorCalls;
        beforeEach(async () => {
            commitsByAuthorCalls = nockHelpers_1.mockGqlRequest({
                name: 'MyQuery',
                statusCode: 200,
                body: { data: 'some data' },
            });
            res = await apiRequestV4_1.apiRequestV4({
                accessToken: 'myAccessToken',
                githubApiBaseUrlV4: 'http://localhost/graphql',
                query: 'query MyQuery{ foo }',
                variables: { foo: 'bar' },
            });
        });
        it('should return correct response', async () => {
            expect(res).toEqual('some data');
        });
        it('should call with correct args', async () => {
            expect(commitsByAuthorCalls).toEqual([
                {
                    query: 'query MyQuery{ foo }',
                    variables: { foo: 'bar' },
                },
            ]);
        });
    });
    describe('when request fails with error messages', () => {
        beforeEach(() => {
            nockHelpers_1.mockGqlRequest({
                name: 'MyQuery',
                statusCode: 500,
                body: {
                    errors: [{ message: 'some error' }, { message: 'some other error' }],
                },
            });
        });
        it('should return parsed github error', async () => {
            return expect(apiRequestV4_1.apiRequestV4({
                accessToken: 'myAccessToken',
                githubApiBaseUrlV4: 'http://localhost/graphql',
                query: 'query MyQuery{ foo }',
                variables: {
                    foo: 'bar',
                },
            })).rejects.toThrowError(new HandledError_1.HandledError(`some error, some other error (Github v4)`));
        });
    });
    describe('when request fails without error messages', () => {
        beforeEach(() => {
            nockHelpers_1.mockGqlRequest({
                name: 'MyQuery',
                statusCode: 500,
                body: { data: { foo: 'bar' } },
            });
        });
        it('should return parsed github error', async () => {
            return expect(apiRequestV4_1.apiRequestV4({
                accessToken: 'myAccessToken',
                githubApiBaseUrlV4: 'http://localhost/graphql',
                query: 'query MyQuery{ foo }',
                variables: {
                    foo: 'bar',
                },
            })).rejects.toThrowErrorMatchingSnapshot();
        });
    });
});
