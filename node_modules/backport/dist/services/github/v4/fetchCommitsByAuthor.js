"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getExistingTargetPullRequests = exports.fetchCommitsByAuthor = void 0;
const lodash_isempty_1 = __importDefault(require("lodash.isempty"));
const ora_1 = __importDefault(require("ora"));
const filterEmpty_1 = require("../../../utils/filterEmpty");
const HandledError_1 = require("../../HandledError");
const commitFormatters_1 = require("../commitFormatters");
const apiRequestV4_1 = require("./apiRequestV4");
const fetchAuthorId_1 = require("./fetchAuthorId");
const getTargetBranchesFromLabels_1 = require("./getTargetBranchesFromLabels");
async function fetchCommitsByAuthor(options) {
    const { accessToken, branchLabelMapping, githubApiBaseUrlV4, maxNumber, path, repoName, repoOwner, sourceBranch, } = options;
    const query = /* GraphQL */ `
    query CommitsByAuthor(
      $repoOwner: String!
      $repoName: String!
      $maxNumber: Int!
      $sourceBranch: String!
      $authorId: ID
      $historyPath: String
    ) {
      repository(owner: $repoOwner, name: $repoName) {
        ref(qualifiedName: $sourceBranch) {
          target {
            ... on Commit {
              history(
                first: $maxNumber
                author: { id: $authorId }
                path: $historyPath
              ) {
                edges {
                  node {
                    oid
                    message
                    associatedPullRequests(first: 1) {
                      edges {
                        node {
                          repository {
                            owner {
                              login
                            }
                            name
                          }
                          number
                          mergeCommit {
                            oid
                          }
                          labels(first: 50) {
                            nodes {
                              name
                            }
                          }
                          timelineItems(
                            last: 20
                            itemTypes: CROSS_REFERENCED_EVENT
                          ) {
                            edges {
                              node {
                                ... on CrossReferencedEvent {
                                  source {
                                    __typename
                                    ... on PullRequest {
                                      title
                                      state
                                      baseRefName
                                      commits(first: 20) {
                                        edges {
                                          node {
                                            commit {
                                              message
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  `;
    const spinner = ora_1.default(`Loading commits from branch "${sourceBranch}"...`).start();
    let res;
    try {
        const authorId = await fetchAuthorId_1.fetchAuthorId(options);
        res = await apiRequestV4_1.apiRequestV4({
            githubApiBaseUrlV4,
            accessToken,
            query,
            variables: {
                repoOwner,
                repoName,
                sourceBranch,
                maxNumber,
                authorId,
                historyPath: path || null,
            },
        });
        spinner.stop();
    }
    catch (e) {
        spinner.fail();
        throw e;
    }
    if (res.repository.ref === null) {
        throw new HandledError_1.HandledError(`The upstream branch "${sourceBranch}" does not exist. Try specifying a different branch with "--source-branch <your-branch>"`);
    }
    const commits = res.repository.ref.target.history.edges.map((edge) => {
        // it is assumed that there can only be a single PR associated with a commit
        // that assumption might not hold true forever but for now it works out
        const pullRequestEdge = edge.node.associatedPullRequests.edges[0];
        const commitMessage = edge.node.message;
        const sha = edge.node.oid;
        // get the source pull request unless the commit was merged directly
        const sourcePullRequest = getSourcePullRequest({
            pullRequestEdge,
            options,
            sha,
        });
        // find any existing target pull requests
        const existingTargetPullRequests = getExistingTargetPullRequests(commitMessage, sourcePullRequest);
        const pullNumber = (sourcePullRequest === null || sourcePullRequest === void 0 ? void 0 : sourcePullRequest.node.number) || getPullNumberFromMessage(commitMessage);
        const formattedMessage = commitFormatters_1.getFormattedCommitMessage({
            message: commitMessage,
            pullNumber,
            sha,
        });
        const labels = sourcePullRequest === null || sourcePullRequest === void 0 ? void 0 : sourcePullRequest.node.labels.nodes.map((node) => node.name);
        const targetBranchesFromLabels = getTargetBranchesFromLabels_1.getTargetBranchesFromLabels({
            labels,
            branchLabelMapping,
        });
        return {
            sourceBranch,
            targetBranchesFromLabels,
            sha,
            formattedMessage,
            pullNumber,
            existingTargetPullRequests,
        };
    });
    // terminate if not commits were found
    if (lodash_isempty_1.default(commits)) {
        const pathText = options.path
            ? ` touching files in path: "${options.path}"`
            : '';
        const errorText = options.all
            ? `There are no commits in this repository${pathText}`
            : `There are no commits by "${options.author}" in this repository${pathText}. Try with \`--all\` for commits by all users or \`--author=<username>\` for commits from a specific user`;
        throw new HandledError_1.HandledError(errorText);
    }
    return commits;
}
exports.fetchCommitsByAuthor = fetchCommitsByAuthor;
function getPullNumberFromMessage(firstMessageLine) {
    const matches = firstMessageLine.match(/\(#(\d+)\)/);
    if (matches) {
        return parseInt(matches[1], 10);
    }
}
function getSourcePullRequest({ pullRequestEdge, options, sha, }) {
    if ((pullRequestEdge === null || pullRequestEdge === void 0 ? void 0 : pullRequestEdge.node.repository.name) === options.repoName &&
        pullRequestEdge.node.repository.owner.login === options.repoOwner &&
        pullRequestEdge.node.mergeCommit.oid === sha) {
        return pullRequestEdge;
    }
}
function getExistingTargetPullRequests(commitMessage, sourcePullRequest) {
    if (!sourcePullRequest) {
        return [];
    }
    const firstMessageLine = commitFormatters_1.getFirstCommitMessageLine(commitMessage);
    return sourcePullRequest.node.timelineItems.edges
        .filter(filterEmpty_1.filterEmpty)
        .filter((item) => {
        const { source } = item.node;
        const isPullRequest = source.__typename === 'PullRequest';
        const isMergedOrOpen = source.state === 'MERGED' || source.state === 'OPEN';
        if (!isPullRequest || !isMergedOrOpen) {
            return false;
        }
        const commitMatch = source.commits.edges.some((commit) => {
            return (commitFormatters_1.getFirstCommitMessageLine(commit.node.commit.message) ===
                firstMessageLine);
        });
        const prTitleMatch = source.title.includes(firstMessageLine);
        const prNumberMatch = source.title.includes(sourcePullRequest.node.number.toString());
        return commitMatch || (prTitleMatch && prNumberMatch);
    })
        .map((item) => {
        const { source } = item.node;
        return {
            branch: source.baseRefName,
            state: source.state,
        };
    });
}
exports.getExistingTargetPullRequests = getExistingTargetPullRequests;
