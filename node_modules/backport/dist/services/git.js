"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pushBackportBranch = exports.getRepoForkOwner = exports.deleteBackportBranch = exports.createBackportBranch = exports.setCommitAuthor = exports.getUnstagedFiles = exports.getConflictingFiles = exports.finalizeCherrypick = exports.cherrypick = exports.addRemote = exports.deleteRemote = exports.cloneRepo = exports.getRemoteUrl = exports.deleteRepo = exports.repoExists = void 0;
const path_1 = require("path");
const del_1 = __importDefault(require("del"));
const lodash_isempty_1 = __importDefault(require("lodash.isempty"));
const lodash_uniq_1 = __importDefault(require("lodash.uniq"));
const ora_1 = __importDefault(require("ora"));
const HandledError_1 = require("./HandledError");
const child_process_promisified_1 = require("./child-process-promisified");
const env_1 = require("./env");
const fs_promisified_1 = require("./fs-promisified");
const commitFormatters_1 = require("./github/commitFormatters");
const logger_1 = require("./logger");
async function folderExists(path) {
    try {
        const stats = await fs_promisified_1.stat(path);
        return stats.isDirectory();
    }
    catch (e) {
        if (e.code === 'ENOENT') {
            return false;
        }
        throw e;
    }
}
function repoExists(options) {
    return folderExists(env_1.getRepoPath(options));
}
exports.repoExists = repoExists;
function deleteRepo(options) {
    const repoPath = env_1.getRepoPath(options);
    return del_1.default(repoPath);
}
exports.deleteRepo = deleteRepo;
function getRemoteUrl({ repoName, accessToken, gitHostname }, repoOwner) {
    return `https://${accessToken}@${gitHostname}/${repoOwner}/${repoName}.git`;
}
exports.getRemoteUrl = getRemoteUrl;
function cloneRepo(options, callback) {
    return new Promise((resolve, reject) => {
        const cb = (error) => {
            if (error) {
                reject(error);
            }
            else {
                resolve();
            }
        };
        const execProcess = child_process_promisified_1.execAsCallback(`git clone ${getRemoteUrl(options, options.repoOwner)} --progress`, { cwd: env_1.getRepoOwnerPath(options), maxBuffer: 100 * 1024 * 1024 }, cb);
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (execProcess.stderr) {
            execProcess.stderr.on('data', (data) => {
                const regex = /^Receiving objects:\s+(\d+)%/;
                const [, progress] = data.toString().match(regex) || [];
                if (progress) {
                    callback(progress);
                }
            });
        }
    });
}
exports.cloneRepo = cloneRepo;
async function deleteRemote(options, remoteName) {
    try {
        await child_process_promisified_1.exec(`git remote rm ${remoteName}`, { cwd: env_1.getRepoPath(options) });
    }
    catch (e) {
        const isExecError = e.cmd && e.code === 128;
        // re-throw if error is not an exec related error
        if (!isExecError) {
            throw e;
        }
    }
}
exports.deleteRemote = deleteRemote;
async function addRemote(options, remoteName) {
    try {
        await child_process_promisified_1.exec(`git remote add ${remoteName} ${getRemoteUrl(options, remoteName)}`, { cwd: env_1.getRepoPath(options) });
    }
    catch (e) {
        // note: swallowing error
        return;
    }
}
exports.addRemote = addRemote;
async function cherrypick(options, commit) {
    await child_process_promisified_1.exec(`git fetch ${options.repoOwner} ${commit.sourceBranch}:${commit.sourceBranch} --force`, { cwd: env_1.getRepoPath(options) });
    const mainline = options.mainline != undefined ? ` --mainline ${options.mainline}` : '';
    const cmd = `git cherry-pick${mainline} ${commit.sha}`;
    try {
        await child_process_promisified_1.exec(cmd, { cwd: env_1.getRepoPath(options) });
        return { needsResolving: false };
    }
    catch (e) {
        // missing `mainline` option
        if (e.message.includes('is a merge but no -m option was given')) {
            throw new HandledError_1.HandledError('Cherrypick failed because the selected commit was a merge commit. Please try again by specifying the parent with the `mainline` argument:\n\n> backport --mainline\n\nor:\n\n> backport --mainline <parent-number>\n\nOr refer to the git documentation for more information: https://git-scm.com/docs/git-cherry-pick#Documentation/git-cherry-pick.txt---mainlineparent-number');
        }
        // commit was already backported
        if (e.message.includes('The previous cherry-pick is now empty')) {
            const shortSha = commitFormatters_1.getShortSha(commit.sha);
            throw new HandledError_1.HandledError(`Cherrypick failed because the selected commit (${shortSha}) is empty. This is most likely caused by attemping to backporting a commit that was already backported`);
        }
        if (e.message.includes(`bad object ${commit.sha}`)) {
            throw new HandledError_1.HandledError(`Backport failed because commit "${commit.sha}" was not found`);
        }
        const isCherryPickError = e.cmd === cmd;
        const hasConflicts = !lodash_isempty_1.default(await getConflictingFiles(options));
        const hasUnstagedFiles = !lodash_isempty_1.default(await getUnstagedFiles(options));
        if (isCherryPickError && (hasConflicts || hasUnstagedFiles)) {
            return { needsResolving: true };
        }
        // re-throw error if there are no conflicts to solve
        throw e;
    }
}
exports.cherrypick = cherrypick;
async function finalizeCherrypick(options) {
    var _a;
    try {
        const noVerify = options.noVerify ? ` --no-verify` : '';
        await child_process_promisified_1.exec(`git commit --no-edit${noVerify}`, {
            cwd: env_1.getRepoPath(options),
        });
    }
    catch (e) {
        const isCommitError = (_a = e.stdout) === null || _a === void 0 ? void 0 : _a.includes('nothing to commit');
        if (!isCommitError) {
            throw e;
        }
        logger_1.logger.info(`git commit failed - probably because the changes were manually committed`, e);
    }
}
exports.finalizeCherrypick = finalizeCherrypick;
async function getConflictingFiles(options) {
    const repoPath = env_1.getRepoPath(options);
    try {
        await child_process_promisified_1.exec(`git --no-pager diff --check`, { cwd: repoPath });
        return [];
    }
    catch (e) {
        const isConflictError = e.cmd && e.code === 2;
        if (isConflictError) {
            const files = e.stdout
                .split('\n')
                .filter((line) => !!line.trim() && !line.startsWith('+') && !line.startsWith('-'))
                .map((line) => {
                const posSeparator = line.indexOf(':');
                const filename = line.slice(0, posSeparator).trim();
                return path_1.resolve(repoPath, filename);
            });
            return lodash_uniq_1.default(files);
        }
        // rethrow error since it's unrelated
        throw e;
    }
}
exports.getConflictingFiles = getConflictingFiles;
// retrieve the list of files that could not be cleanly merged
async function getUnstagedFiles(options) {
    const repoPath = env_1.getRepoPath(options);
    const res = await child_process_promisified_1.exec(`git --no-pager diff --name-only`, {
        cwd: repoPath,
    });
    const files = res.stdout
        .split('\n')
        .filter((file) => !!file)
        .map((file) => path_1.resolve(repoPath, file));
    return lodash_uniq_1.default(files);
}
exports.getUnstagedFiles = getUnstagedFiles;
async function setCommitAuthor(options, username) {
    const spinner = ora_1.default(`Changing author to "${options.username}"`).start();
    try {
        const res = await child_process_promisified_1.exec(`git commit --amend --no-edit --author "${username} <${username}@users.noreply.github.com>"`, { cwd: env_1.getRepoPath(options) });
        spinner.succeed();
        return res;
    }
    catch (e) {
        spinner.fail();
        throw e;
    }
}
exports.setCommitAuthor = setCommitAuthor;
// How the commit flows:
// ${sourceBranch} ->   ${backportBranch}   -> ${targetBranch}
//     master      ->  backport/7.x/pr-1234 ->      7.x
async function createBackportBranch({ options, targetBranch, backportBranch, }) {
    var _a, _b;
    const spinner = ora_1.default('Pulling latest changes').start();
    try {
        const res = await child_process_promisified_1.exec(`git reset --hard && git clean -d --force && git fetch ${options.repoOwner} ${targetBranch} && git checkout -B ${backportBranch} ${options.repoOwner}/${targetBranch} --no-track`, { cwd: env_1.getRepoPath(options) });
        spinner.succeed();
        return res;
    }
    catch (e) {
        spinner.fail();
        const isBranchInvalid = ((_a = e.stderr) === null || _a === void 0 ? void 0 : _a.toLowerCase().includes(`couldn't find remote ref`)) || ((_b = e.stderr) === null || _b === void 0 ? void 0 : _b.toLowerCase().includes(`invalid refspec`));
        if (isBranchInvalid) {
            throw new HandledError_1.HandledError(`The branch "${targetBranch}" is invalid or doesn't exist`);
        }
        throw e;
    }
}
exports.createBackportBranch = createBackportBranch;
async function deleteBackportBranch({ options, backportBranch, }) {
    const spinner = ora_1.default().start();
    await child_process_promisified_1.exec(`git reset --hard && git checkout ${options.sourceBranch} && git branch -D ${backportBranch}`, { cwd: env_1.getRepoPath(options) });
    spinner.stop();
}
exports.deleteBackportBranch = deleteBackportBranch;
/*
 * Returns the repo owner of the forked repo or the source repo
 */
function getRepoForkOwner(options) {
    return options.fork ? options.username : options.repoOwner;
}
exports.getRepoForkOwner = getRepoForkOwner;
async function pushBackportBranch({ options, backportBranch, }) {
    var _a;
    const repoForkOwner = getRepoForkOwner(options);
    const spinnerText = `Pushing branch "${repoForkOwner}:${backportBranch}"`;
    const spinner = ora_1.default(spinnerText).start();
    if (options.dryRun) {
        spinner.succeed(`Dry run: ${spinnerText}`);
        return;
    }
    try {
        const res = await child_process_promisified_1.exec(`git push ${repoForkOwner} ${backportBranch}:${backportBranch} --force`, { cwd: env_1.getRepoPath(options) });
        spinner.succeed();
        return res;
    }
    catch (e) {
        spinner.fail();
        if ((_a = e.stderr) === null || _a === void 0 ? void 0 : _a.toLowerCase().includes(`repository not found`)) {
            throw new HandledError_1.HandledError(`Error pushing to https://github.com/${repoForkOwner}/${options.repoName}. Repository does not exist. Either fork the source repository (https://github.com/${options.repoOwner}/${options.repoName}) or disable fork mode "--fork false".  Read more about "fork mode" in the docs: https://github.com/sqren/backport/blob/3a182b17e0e7237c12915895aea9d71f49eb2886/docs/configuration.md#fork`);
        }
        throw e;
    }
}
exports.pushBackportBranch = pushBackportBranch;
