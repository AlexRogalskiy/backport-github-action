"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const createDebug = require("debug");
const github_cherry_pick_1 = require("github-cherry-pick");
const git_1 = require("shared-github-internals/lib/git");
const debug = createDebug("github-backport");
const backportPullRequest = ({ 
// Should only be used in tests.
_intercept = () => Promise.resolve(), base, body: givenBody, head: givenHead, octokit, owner, pullRequestNumber, repo, title: givenTitle, }) => __awaiter(this, void 0, void 0, function* () {
    const { data: { title: originalTitle }, } = yield octokit.pulls.get({
        owner,
        pull_number: pullRequestNumber,
        repo,
    });
    const { body = `Backport #${pullRequestNumber}.`, head = `backport-${pullRequestNumber}-to-${base}`, title = `[Backport ${base}] ${originalTitle}`, } = { body: givenBody, head: givenHead, title: givenTitle };
    debug("starting", {
        base,
        body,
        head,
        owner,
        pullRequestNumber,
        repo,
        title,
    });
    const baseSha = yield git_1.fetchRefSha({
        octokit,
        owner,
        ref: base,
        repo,
    });
    debug("fetching commits");
    const commits = yield git_1.fetchCommits({
        octokit,
        owner,
        pullRequestNumber,
        repo,
    });
    debug("creating reference");
    yield git_1.createRef({
        octokit,
        owner,
        ref: head,
        repo,
        sha: baseSha,
    });
    debug("reference created");
    yield _intercept({ commits });
    try {
        try {
            debug("cherry-picking commits", commits);
            const headSha = yield github_cherry_pick_1.cherryPickCommits({
                commits,
                head,
                octokit,
                owner,
                repo,
            });
            debug("commits cherry-picked", headSha);
        }
        catch (error) {
            debug("commits could not be cherry-picked", error);
            throw new Error(`Commits ${JSON.stringify(commits)} could not be cherry-picked on top of ${base}`);
        }
        debug("creating pull request");
        const { data: { number: backportedPullRequestNumber }, } = yield octokit.pulls.create({
            base,
            body,
            head,
            owner,
            repo,
            title,
        });
        debug("pull request created", backportedPullRequestNumber);
        return backportedPullRequestNumber;
    }
    catch (error) {
        debug("rollbacking reference creation", error);
        yield git_1.deleteRef({ octokit, owner, ref: head, repo });
        debug("reference creation rollbacked");
        throw error;
    }
});
exports.backportPullRequest = backportPullRequest;
